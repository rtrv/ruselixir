---
title: Списки с ключевыми словами и мэпы
---
# Списки с ключевыми словами и мэпы

До сих пор мы не говорили ни о каких ассоциативных структурах данных, такие структуры позволяют ассоциировать некоторое значение (или несколько значений) с ключом.

В Elixir у нас есть два вида ассоциативных структур данных: списки с ключевыми словами и мэпы. Самое время познакомиться с ними!

## Списки с ключевыми словами

Во многих функциональных языках программирования распространено использование массивов из кортежей, которые состоят из двух элементов, чтобы представить структуру из пар ключ-значение. В Elixir, когда у нас есть список кортежей, и первый элемент кортежа (ключ) - это атом, мы называем это списком с ключевыми словами (keyword list):

```elixir
iex> list = [{:a, 1}, {:b, 2}]
[a: 1, b: 2]
iex> list == [a: 1, b: 2]
true
```

Как вы можете увидеть выше, Elixir поддерживает специальный синтаксис для объявления таких списков: `[key: value]`. Под капотом это интерпретируется как список кортежей выше. Т.к. списки с ключевыми словами - объекты типа List, мы можем делать с ними все операции, доступные для списков. Например, можно добавить новое значение, используя `++`:

```elixir
iex> list ++ [c: 3]
[a: 1, b: 2, c: 3]
iex> [a: 0] ++ list
[a: 0, a: 1, b: 2]
```

Обратите внимание, что при поиске будут возвращаться значения, стоящие ближе к началу списка:

```elixir
iex> new_list = [a: 0] ++ list
[a: 0, a: 1, b: 2]
iex> new_list[:a]
0
```

Списки с ключевыми словами важны, потому что они имеют три особые характеристики:

* Ключи должны быть атомами.
* Ключи отсортированы так, как их задал разработчик.
* Ключи могут быть добавлены более одного раза.

Например, [библиотека Ecto](https://github.com/elixir-lang/ecto) использует эти особенности для предоставления элегантного DSL для написания запросов к базам данных:

```elixir
query = from w in Weather,
      where: w.prcp > 0,
      where: w.temp < 20,
     select: w
```

Эти характеристики являются причиной, по которой списки с ключами являются стандартным механизмом передачи опций в функции Elixir. В главе 5, когда мы обсуждали макрос `if/2`, мы упоминали, что поддерживается следующий синтаксис:

```elixir
iex> if false, do: :this, else: :that
:that
```

Пары `do:` и `else:` - это списки с ключевыми словами! Фактически, вызов выше соответствует этому:

```elixir
iex> if(false, [do: :this, else: :that])
:that
```

А это, как мы видели выше, тоже самое, что:

```elixir
iex> if(false, [{:do, :this}, {:else, :that}])
:that
```

Когда список с ключами является последним аргументом функции, квадратные скобки не обязательны.

Хотя мы можем сравнивать по шаблону списки с ключами, это редко делается на практике, потому что предусматривает соответствие количества элементов и их порядка:

```elixir
iex> [a: a] = [a: 1]
[a: 1]
iex> a
1
iex> [a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
iex> [b: b, a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
```

Для манипуляций со списками с ключевыми словами Elixir предоставляет [модуль `Keyword`](https://hexdocs.pm/elixir/Keyword.html). Помните, что списки с ключами - это просто списки, с такими же линейными характеристиками производительности. Чем длиннее список, тем дольше будет поиск по ключу, подсчёт количества элементов и т.д. По этой причине такие списки используются в Elixir главным образом для передачи дополнительных значений. Если вам нужно хранить много элементов или исключить дублирование ключей, вам следует использовать мэпы.

## Мэпы

Если вам нужно хранилище пар ключ-значение, мэпы - та структура, которую предлагает Elixir в первую очередь. Мэп создаётся используя `%{}` синтаксис:

```elixir
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> map[:a]
1
iex> map[2]
:b
iex> map[:c]
nil
```

Сравнивая со списками с ключевыми словами, мы уже можем увидеть два отличия:

* Мэпы допускают любое значение в качестве ключа.
* Ключи мэпов не следуют какому-то определённому порядку.

В отличии от списков с ключами, мэпы очень удобны для сравнения по шаблону. Когда мэп используется в шаблоне, он всегда будет соответствовать подмножеству сравниваемых значений:

```elixir
iex> %{} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> a
1
iex> %{:c => c} = %{:a => 1, 2 => :b}
** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
```

Как показано выше, мэп соответствует до тех пор, пока ключи в шаблоне существуют и в мэпе справа. Также, пустой мэп будет соответствовать любому мэпу.

Переменные могут быть использованы для доступа, сравнения и добавления ключей в мэпы:

```elixir
iex> n = 1
1
iex> map = %{n => :one}
%{1 => :one}
iex> map[n]
:one
iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}
%{1 => :one, 2 => :two, 3 => :three}
```

[Модуль `Map`](https://hexdocs.pm/elixir/Map.html) предоставляет API, очень похожее на модуль `Keyword`, с удобными функциями для манипуляции с мэпами:

```elixir
iex> Map.get(%{:a => 1, 2 => :b}, :a)
1
iex> Map.put(%{:a => 1, 2 => :b}, :c, 3)
%{2 => :b, :a => 1, :c => 3}
iex> Map.to_list(%{:a => 1, 2 => :b})
[{2, :b}, {:a, 1}]
```

Мэпы имеют следующий синтаксис для обновления значения для ключа:

```elixir
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> %{map | 2 => "two"}
%{2 => "two", :a => 1}
iex> %{map | :c => 3}
** (KeyError) key :c not found in: %{2 => :b, :a => 1}
```

Синтаксис выше подразумевает, что ключ существует. Он не может быть использован для добавления новых сенсоров. Например, использование ключа `:c` вызвало ошибку, потому что такого ключа нет в мэпе.

Когда все ключи в мэпе - это атомы, вы можете использовать синтаксис ключевых слов для удобства:

```elixir
iex> map = %{a: 1, b: 2}
%{a: 1, b: 2}
```

Другое интересное свойство мэпов: у них есть свой собственный синтаксис для доступа к ключам-атомам:

```elixir
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> map.a
1
iex> map.c
** (KeyError) key :c not found in: %{2 => :b, :a => 1}
```

Elixir разработчики обычно предпочитают использовать синтаксис `map.field` и сравнение по шаблону, вместо функций из модуля `Map`, при работе с мэпами, потому что они предоставляют assertive (корректный перевод?) стиль программирования. [В этом посте](http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/) показаны преимущества и примеры, как получить более лаконичное и быстрое ПО при помощи написания assertive кода на Elixir.

> Обратите внимание: Мэпы недавно были представлени в Erlang <abbr title="Virtual Machine">VM</abbr> и только начиная с Elixir v1.2 они способны эффективно хранить миллионы ключей. Если же вы работаете с предыдущими версиями Elixir (v1.0 или v1.1) и вам нужна поддержка хотя бы сотен ключей, вам может подойти [модуль `HashDict`](https://hexdocs.pm/elixir/HashDict.html).

## Вложенные структуры данных

Мы часто будем встречаться с мэпами внутри мэпов, или даже со списками с ключевыми словами внутри мэпов и т.п. Elixir позаботился об удобстве манипуляций со вложенными структурами данных с помощью `put_in/2`, `update_in/2` и других макросов, которые дают такое же удобство, как в имеративных языках, сохраняя при этом иммутабельность.

Представьте, что у вас есть следующая структура:

```elixir
iex> users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]
[john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]
```

У нас есть список с ключами, в котором каждое значение - мэп с именем, возрастом и списком предпочитаемых языков программирования пользователей. Если мы хотим получить доступ к возрасту пользователя john, мы можем написать:

```elixir
iex> users[:john].age
27
```

Аналогичный синтаксис можно использовать для обновления значения:

```elixir
iex> users = put_in users[:john].age, 31
[john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]
```

Макрос `update_in/2` похож, но позволяет нам передать функцию, которая будет управлять изменением значеня. Например, давайте уберём "Clojure" из списка языков Mary:

```elixir
iex> users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end
[john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}]
```

Это далеко не вся информация о `put_in/2` и `update_in/2`, также есть макрос `get_and_update_in/2`, который позволяет нам получить значение и одновременно с этим обновить структуру данных. Есть также `put_in/3`, `update_in/3` и `get_and_update_in/3`, которые получают доступ в структуру данных динамически. [Посмотрите их исчерпывающую документацию в модуле `Kernel`](https://hexdocs.pm/elixir/Kernel.html)

На этом мы закончим введение в ассоциативные структуры данных в Elixir. В последствии вы обнаружите, что имея списки с ключами и мэпы, у вас всегда будет подходящий инструмент для решения проблем, в которых требуются ассоциативные структуры данных.
