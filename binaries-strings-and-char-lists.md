---
title: Двоичные данные, строки и списки символов
next_page: keywords-and-maps
prev_page: case-cond-and-if
---

В "Базовых типа" мы познакомились со строками и использовали функцию `is_binary/1` для проверок:

```elixir
iex> string = "hello"
"hello"
iex> is_binary(string)
true
```

В этой главе мы поймём, что такое двоичные данные (binaries), как они связаны со строками, и что такое значения в одинарных кавычках `'like this'` в Elixir.

## UTF-8 и Юникод

Строка в UTF-8 представляет собой бинарную последовательность. Для понимания, что мы подразумеваем, следует понять разницу между байтами и code points (кодовые обозначения?).

Стандарт Unicode связывает кодовые обозначения со многими известными символами. Например, латинская буква `a` имеет кодовое обозначение `97`, тогда как буква `ł` имеет код `322`. Чтобы записать строку `"hełło"` на диск, нужно конвертировать эти коды в байты. Если мы примем за правило, что один байт соответствует одному кодовому обозначению, мы не сможем записать строку `"hełło"`, потому что она использует код `322` для `ł`, а один байт может представлять число от `0` до `255`. Но, раз мы можем прочитать `"hełło"` на экране, есть *какой-то способ* записать такую строку. Это место, где начинает работать кодировка.

Для представления кодовых обозначений в виде байт, нужно как-то их закодировать. Elixir выбрал кодировку UTF-8 своей главной и стандартной кодировкой. Когда мы говорим, что UTF-8 закодирован в двоичном виде, мы имеем ввиду, что строка - это набор байт, представляющих некоторые кодовые обозначения, в соответствии с правилами кодировки UTF-8.

Т.к. у нас есть символы вроде `ł`, соответствующий коду `322`, нам нужно больше одного байта для их представления. Поэтому мы видим разницу при вычислении `byte_size/1` в сравнении с результатом `String.length/1`:

```elixir
iex> string = "hełło"
"hełło"
iex> byte_size(string)
7
iex> String.length(string)
5
```

Так, `byte_size/1` считает количество байт, необходимых для представления строки, а `String.length/1` считает символы.

> Обратите внимание: если вы работаете под Windows, есть шанс, что ваш терминал не использует UTF-8 по умолчанию. Вы можете изменить кодировку текущей сессии, выполнив `chcp 65001` перед запуском `iex` (`iex.bat`).

UTF-8 нужен один байт для представления символов `h`, `e`, и `o`, но два байта для представления `ł`. В Elixir вы можете узнать код символа с помощью `?`:

```elixir
iex> ?a
97
iex> ?ł
322
```

Вы можете также использовать функции из [модуля `string`](https://hexdocs.pm/elixir/String.html) для разделения строки на индивидуальные символы, каждый из которых будет строкой длины 1:

```elixir
iex> String.codepoints("hełło")
["h", "e", "ł", "ł", "o"]
```

Вы увидите, что Elixir имеет отличную поддержку работы со строками. Он также поддерживает многие операции Юникода. Фактически, Elixir успешно проходит все тесты, показанные в статье ["The string type is broken"](http://mortoray.com/2013/11/27/the-string-type-is-broken/).

Однако, строки - это только часть истории. Раз строки являются бинарными, и мы использовали функцию `is_binary/1`, Elixir должен иметь более мощный тип, лежащий в основе строк. И он есть! Поговорим о бинарных данных.

## Бинарные данные (и битовые строки)

В Elixir вы можете определить бинарную последовательность, используя `<<>>`:

```elixir
iex> <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> byte_size(<<0, 1, 2, 3>>)
4
```

Бинарные данные (binary) - это последовательность байт. Эти байты могут быть записаны в любом порядке, даже если эта последовательность не будет корректной строкой:

```elixir
iex> String.valid?(<<239, 191, 191>>)
false
```

Оператор конкатенации строк на самом деле оператор бинарной конкатенации:

```elixir
iex> <<0, 1>> <> <<2, 3>>
<<0, 1, 2, 3>>
```

Часто используемы трюк в Elixir - конкатенация нулевого байта `<<0>>` к строке, чтобы увидеть её бинарное представление:

```elixir
iex> "hełło" <> <<0>>
<<104, 101, 197, 130, 197, 130, 111, 0>>
```

Каждое число в бинарной последовательности должно помещаться в один байт, а значит, быть не больше 255. Существую модификаторы для хранения числе больше, чем 255 или конвертации кодовых обозначений в их UTF-8 представления:

```elixir
iex> <<255>>
<<255>>
iex> <<256>> # truncated
<<0>>
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>
iex> <<256 :: utf8>> # the number is a code point
"Ā"
iex> <<256 :: utf8, 0>>
<<196, 128, 0>>
```

Если в байте 8 бит, что произойдёт, если мы укажем размер в 1 бит?

```elixir
iex> <<1 :: size(1)>>
<<1::size(1)>>
iex> <<2 :: size(1)>> # truncated
<<0::size(1)>>
iex> is_binary(<<1 :: size(1)>>)
false
iex> is_bitstring(<<1 :: size(1)>>)
true
iex> bit_size(<< 1 :: size(1)>>)
1
```

Значение больше не бинарное, но является битовой строкой -- набором битов! Таким образом бинарная последовательность - это битовая трока, количество бит в которой делится на 8.

```elixir
iex>  is_binary(<<1 :: size(16)>>)
true
iex>  is_binary(<<1 :: size(15)>>)
false
```

Мы можем также сравнивать по шаблону бинарные последовательности и битовые строки:

```elixir
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>
iex> x
2
iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

Обратите внимание, что каждая запись в бинарном шаблоне предусматривает размер 8 бит. Если мы хотим сравнить бинарную последовательность неизвестного размера, можно использовать модификатор binary в конце шаблона:

```elixir
iex> <<0, 1, x :: binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> x
<<2, 3>>
```

Тот же результат может быть достигнут с помощью оператора конкатенации `<>`:

```elixir
iex> "he" <> rest = "hello"
"hello"
iex> rest
"llo"
```

Полную справку о конструкторе `<<>>` бинарных последовательностей / битовых строк можно найти [в документации по Elixir](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1). На этом мы закончим обзор битовых строк, бинарных последовательностей и строк. Строка - это бинарная последовательность в кодировке UTF-8, а бинарная последовательность - битовая строка, число бит в которой делится на 8. Хотя это показывает гибкость, которую даёт Elixir для работы с битами и байтами, 99% времени вы будете работать с бинарными последовательностями, используя функции `is_binary/1` и `byte_size/1`.

## Списки символов (Char lists)

Списки символов - ни что иное как списки из кодовых обозначений. Списки символов можно создать с помощью литералов в одиночных кавычках:

```elixir
iex> 'hełło'
[104, 101, 322, 322, 111]
iex> is_list 'hełło'
true
iex> 'hello'
'hello'
iex> List.first('hello')
104
```

Вы можете увидеть, что список символов хранит не последовательность байт, а кодовые обозначения символов, указанных в одинарных кавычках (помните, что IEx по умолчанию будет выводить только коды, если хотя бы один из них не входит в диапазон ASCII). Таким образом двойные кавычки используются для строк (внутри это бинарная последовательность), одиночные - для списков символов (внутри список).

На практике, списки символов чаще всего используются для взаимодействия с Erlang, в частности со старыми библиотеками, которые не принимают бинарные последовательности в качестве аргументов. Вы можете конвертировать список символов в строку и обратно, используя функции: `to_string/1` и `to_charlist/1`:

```elixir
iex> to_charlist "hełło"
[104, 101, 322, 322, 111]
iex> to_string 'hełło'
"hełło"
iex> to_string :hello
"hello"
iex> to_string 1
"1"
```

Обратите внимание, что эти функции полиморфичны. Они могут конвертировать в строки не только списки символов, но и числа, атомы и т.д.

На это всё с бинарными последовательностями, строками и списками символов. Самое время поговорить о структурах данных, основанных на парах ключ-значение.
