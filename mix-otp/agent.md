---
title: Агент
---

В этой главе мы будем создавать модуль с именем `KV.Bucket`. Этот модуль будет отвечать за хранение основных значений таким образом, что позволит им быть прочитанными и измененными другими процессами.

Если вы пропустили Руководство для начинающих или читали его давно, обязательно перечитайте главу [Processes](/getting-started/processes.html). Мы будем использовать ее в качестве отправной точки.

## Проблема состояния

Эликсир это иммутабельный(immutable) язык, в котором нет ничего совместно используемого по умолчанию. Если мы хотим сохранять состояние, создавать buckets, записывать и читать значения из нескольких мест, у нас есть два основных варианта в Эликсире:

* Processes - процессы
* [ETS (Erlang Term Storage)](http://www.erlang.org/doc/man/ets.html) - хранилище термов Эрланга

Мы уже говорили о процессах, а <abbr title="Erlang Term Storage">ЕТС</abbr> мы будем изучать далее в этом руководстве. Когда дело доходит до процессов, мы редко используем собственные реализации, вместо этого мы пользуемся абстракциями существующими в Эликсире и <abbr title="Open Telecom Platform">OTP</abbr>:

* [Agent](https://hexdocs.pm/elixir/Agent.html) - простая обертка вокруг состояния.
* [GenServer](https://hexdocs.pm/elixir/GenServer.html) - “Универсальный сервер”("Generic server") (процессы), который инкапсулирует состояние, обеспечивает синхронные и асинхронные вызовы, поддерживает горячую замену кода, и многое другое.
* [GenEvent](https://hexdocs.pm/elixir/GenEvent.html) - "Generic event" менеджер, позволяющий публиковать события с несколькими обработчиками.
* [Task](https://hexdocs.pm/elixir/Task.html) - асинхронные блоки вычислений, которые позволяют запускать несколько процессов и извлекать результаты в последующем.

Мы рассмотрим большинство этих абстракций в данном руководстве. Имейте в виду, что все они реализованы на основе процессов, используя базовые возможности, предоставляемые виртуальной машиной, такие как `send`, `receive`, `spawn` и `link`.

## Агенты(Agents)

[Агенты](https://hexdocs.pm/elixir/Agent.html) простые обертки вокруг состояния. Если все, что вы хотите от процесса, чтобы он сохранял состояние, агенты отлично подойдут для этого. Давайте запустим `iex` сессию внутри проекта:

```bash
$ iex -S mix
```
И немного поиграем с агентами:

```iex
iex> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.57.0>}
iex> Agent.update(agent, fn list -> ["eggs" | list] end)
:ok
iex> Agent.get(agent, fn list -> list end)
["eggs"]
iex> Agent.stop(agent)
:ok
```
Мы запустили агента с исходным состоянием пустого списка. Затем обновили состояние агента, добавив новый элемент в голову списка. Второй аргумент [`Agent.update/3`](https://hexdocs.pm/elixir/Agent.html#update/3) это функция, которая принимает текущее состояние агента в качестве входных данных и возвращает новое состояние. Далее, мы вернули текущий список. Второй аргумент [`Agent.get/3`](https://hexdocs.pm/elixir/Agent.html#get/3) это функция, которая принимает состояние в качестве входных данных и возвращает значение, которое Agent.get/3 сам возвращает. Как только мы закончили с агентом, мы можем вызвать [`Agent.stop/3`](https://hexdocs.pm/elixir/Agent.html#stop/3) чтобы остановить процесс агента.

Давайте реализуем наш `KV.Bucket`, используя агентов. Прежде чем приступить к выполнению, давайте сначала напишем несколько тестов. Создадим файл в `test/kv/bucket_test.exs` (вспомните `.exs` расширение) со следующим содержимым:

```elixir
defmodule KV.BucketTest do
  use ExUnit.Case, async: true

  test "stores values by key" do
    {:ok, bucket} = KV.Bucket.start_link
    assert KV.Bucket.get(bucket, "milk") == nil

    KV.Bucket.put(bucket, "milk", 3)
    assert KV.Bucket.get(bucket, "milk") == 3
  end
end
```

Наш первый тест запускает новый `KV.Bucket` и выполняет `get/2` и `put/3` операции в нем с утверждением ожидаемых результатов. Нам не надо явно остонавливать агента, потому что он связан с процессом тестирования и агент выключяется автоматически после окончания теста. Это всегда будет работать, если процессу дают имя.

Также обратите внимание на параметр `async: true`, передаваемый в `ExUnit.Case` . Эта опция разрешает выполнение тестов параллельно с другими `:async` тест кейсами при помощи нескольких процессорных ядер в вашем компьютере. Это крайне полезно для ускорения наших тестов. Однако, `:async` должно быть установлено только в том случае, если тест не предполагает изменить какие либо глобальные значения. Например, если тест требует записи данных в файловую систему, регистрации процессов, или доступ к базе данных, сохраните его синхронно (опусте `:async` вариант), чтобы избежать состояния гонки между тестами.

Наш новый тест должен упасть независимо от включенного или выключеного параметра `async: true`, передаваемого в `ExUnit.Case`, так как функциональность не реализована в тестируемом модуле.

Для того, чтобы устранить падение теста, давайте создадим файл `lib/kv/bucket.ex`.  попробуйте написать реализацию модуля `KV.Bucket` самостоятельно, используя агенты, прежде чем заглядывать в код, представленный ниже.

```elixir
defmodule KV.Bucket do
  @doc """
  Starts a new bucket.
  """
  def start_link do
    Agent.start_link(fn -> %{} end)
  end

  @doc """
  Gets a value from the `bucket` by `key`.
  """
  def get(bucket, key) do
    Agent.get(bucket, &Map.get(&1, key))
  end

  @doc """
  Puts the `value` for the given `key` in the `bucket`.
  """
  def put(bucket, key, value) do
    Agent.update(bucket, &Map.put(&1, key, value))
  end
end
```

Мы используем map, чтобы сохранить наши ключи и значения. Об операторе захвата `&` вы можете почитать в [введении в руководстве](https://github.com/wunsh/elixir-docs-ru/blob/master/modules-and-functions.md#function-capturing).

Теперь, когда модуль `KV.Bucket` определен, наши тесты должны пройти! Вы можете попробовать это самостоятельно, выполнив: `mix test`.

## Настройка тестов коллбэках ExUnit

Прежде чем двигаться дальше и добавлять новую функциональность для `KV.Bucket`, давайте поговорим об коллбэках ExUnit. Как вы можете ожидать, все тесты `KV.Bucket` затребуют bucket, чтобы быть запущенными во время установки и остановится после тестирования. К счастью, ExUnit поддерживает коллбэки, которые позволяют нам пропускать такие повторяющиеся задачи.

Давайте перепишем тест кейс используя коллбэки:

```elixir
defmodule KV.BucketTest do
  use ExUnit.Case, async: true

  setup do
    {:ok, bucket} = KV.Bucket.start_link
    {:ok, bucket: bucket}
  end

  test "stores values by key", %{bucket: bucket} do
    assert KV.Bucket.get(bucket, "milk") == nil

    KV.Bucket.put(bucket, "milk", 3)
    assert KV.Bucket.get(bucket, "milk") == 3
  end
end
```
Сначала мы определили настройку коллбэков с помощью макроса `setup/1`. В `setup/1` коллбэк выполняется перед каждым тестом, в том же процессе в качестве самого теста.

Обратите внимание, что нам нужен механизм для передачи `bucket` pid из вызова теста. Мы делаем это с помощью тестового контекста. Когда мы возвращаем `{:ok, bucket: bucket}` из коллбэка, ExUnit объединит второй элемент кортежа (список) в контекст теста. В контексте теста это мэп, которую затем мы можем соответствовать в определении теста, обеспечивая доступ к этим значениям внутри блока:

```elixir
test "stores values by key", %{bucket: bucket} do
  # `bucket` is now the bucket from the setup block
end
```
Вы можете прочитать больше о ExUnit случаях в документации модуля [ExUnit.Case](https://hexdocs.pm/ex_unit/ExUnit.Case.html) и об коллбэках в [ExUnit.Callbacks документации](https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html).

## Другие действия агента

Получать значение и обновлять состояние агента позволяет вызов функции `Agent.get_and_update/2`. Давайте реализуем функцию `KV.Bucket.delete/2`, которая удаляет ключ из корзины, возвращая его текущее значение:

```elixir
@doc """
Deletes `key` from `bucket`.

Returns the current value of `key`, if `key` exists.
"""
def delete(bucket, key) do
  Agent.get_and_update(bucket, &Map.pop(&1, key))
end
```
Теперь ваша очередь, чтобы написать тест на функциональность выше! Кроме того, обязательно изучите документацию к модулю [`Agent`](https://hexdocs.pm/elixir/Agent.html), чтобы узнать больше о них.

## Клиент/сервер в агентах

Прежде чем мы перейдем к следующей главе, давайте обсудим клиент/серверную раздвоенность агентов. Давайте расширим функцию delete/2, мы просто реализуем:

```elixir
def delete(bucket, key) do
  Agent.get_and_update(bucket, fn dict ->
    Map.pop(dict, key)
  end)
end
```
Все, что мы передали агенту внутри функции происходит в процессе агента. В данном случае, поскольку процесс агента получает и отвечает на наши сообщения, мы говорим о процессе агента сервера. Все что за пределами функции происходит в клиенте.

Это различие имеет важное значение. Если есть дорогостоящие действия, вы должны рассмотреть, где лучше выполнить эти действия, на клиенте или на сервере. Например:

```elixir
def delete(bucket, key) do
  Process.sleep(1000) # puts client to sleep
  Agent.get_and_update(bucket, fn dict ->
    Process.sleep(1000) # puts server to sleep
    Map.pop(dict, key)
  end)
end
```

Когда длительное действие выполняется на сервере, все остальные запросы на этом сервере будут ждать, пока действие зкончится и могут вызвать таймауты клиентов.

В следующей главе мы будем исследовать GenServers, где разделение между клиентами и серверами станет более очевидным.
