---
title: Введение в Mix
next_page: mix-otp/agent
prev_page: where-to-go-next
---

В этом руководстве мы научимся создавать полноценные приложения `elixir`, с деревом надзора(supervisor), конфигурацией, тестами и многим другим.

Приложение работает в качестве распределенного хранилища ключ-значение(key-value). Мы собираемся организовать пары ключ-значение в корзины(buckets) и распространять эти buckets по нескольким узлам(nodes). Мы также построим простой клиент, который позволит подключаться к любому из узлов, а также посылать запросы, такие как:

```
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```
Для того, чтобы создать наше приложение, мы будем использовать три основных инструмента:

* ***Mix*** представляет собой инструмент для сборки, который поставляется вместе с `elixir`, решает задачи по созданию, компиляции, тестированию вашего приложения, управлению его зависимостями и многое другое;

* ***ExUnit*** фрэймворк для модульного тестирования, который поставляется вместе с Эликсиром.

В этой главе мы создадим наш первый проект с использованием `Mix` и исследуем различные особенности в <abbr title="Open Telecom Platform"> OTP, `Mix` и `ExUnit`, давайте начнем.

>Примечание: это руководство требует elixir v1.2.0 или более поздней версии. Вы можете проверить свою версию `elixir` введя в терминале, `elixir ‐‐version`, и установить более свежую версию, если требуется, выполните действия, описанные в первой главе "Начало работы"(introduction) руководства.

>Полный код для этого руководства вы можете найти в [репозитории](https://github.com/josevalim/kv_umbrella)

## Наш первый проект

При установке Эликсира, кроме получения исполняемых файлов `elixir`, `elixirc` и `iex`, вы также получаете исполняемый Эликсиром сценарий `mix`.

Давайте создадим наш первый проект с помощью вызова `mix new` из командной строки. Мы передадим имя проекта в качестве аргумента (`kv` в данном случае), и скажем Mix, что наш главный модуль должен состоять из прописных букв `KV` , а не по умолчанию `Kv`:

```bash
$ mix new kv --module KV
```

Mix создаcт директорию `kv` с несколькими файлами в ней:

    * creating README.md
    * creating .gitignore
    * creating mix.exs
    * creating config
    * creating config/config.exs
    * creating lib
    * creating lib/kv.ex
    * creating test
    * creating test/test_helper.exs
    * creating test/kv_test.exs

Давайте кратко рассмотрим эти сгенерированные файлы.

> Примечание: Mix представляет собой исполняемый Эликсир. Это означает, что для работы `mix` , вы должны иметь его в вашей переменной PATH. Если у вас его нет в PATH, вы можете запустить его из сценария, используя в качестве аргумента `elixir`:
>
> ```bash
> $ bin/elixir bin/mix new kv --module KV
> ```
> Обратите внимание, что директория Эликсира находится в переменной PATH, и вы также можете выполнить любой скрипт с помощью опции -S:
>
> ```bash
> $ bin/elixir -S mix new kv --module KV
> ```
>
> При использовании -S,`elixir` находит сценарий, где бы он не находился в переменной PATH и выполняет его.

## Компиляция проекта

Файл `mix.exs` был сгенерирован внутри нашей новой папке проекта (`kv`) и его основной задачей является настроить наш проект. Давайте взглянем на него (комментарии удалены):

```elixir
defmodule KV.Mixfile do
  use Mix.Project

  def project do
    [app: :kv,
     version: "0.1.0",
     elixir: "~> 1.3",
     start_permanent: Mix.env == :prod,
     deps: deps()]
  end

  def application do
    [extra_applications: [:logger]]
  end

  defp deps do
    []
  end
end
```

`mix.exs` определяет две открытые функции: `project`, которая возвращает конфигурацию пректа, определяя параметры, такие как имя проекта, версию приложения, версию языка `elixir`, и `application`, которая используется, чтобы генерировать файл приложения.

В `mix.exs` также представлена закрытая функция `deps`, которая вызывается из функции `project`, которая определяет зависимости нашего проекта. Определение `deps` как отдельной функции не является обязательным, но это помогает держать конфигурацию проекта аккуратном виде.

Mix также создает файл `lib/kv.ex`, в котором просто определяется модуль:

```elixir
defmodule KV do
end
```

Этой структуры достаточно для компиляции нашего проекта:

```bash
$ cd kv
$ mix compile
```

Мы получим:

    Compiling 1 file (.ex)
    Generated kv app

Файл `lib/kv.ex` был скомпилирован, манифест приложения `kv.app` был создан и все протоколы были объединены, как описано в руководстве по началу работы [смотри protocols](https://github.com/wunsh/elixir-docs-ru/blob/master/protocols.md). Все артефакты компиляции помещаются в директорию `_build`, используя параметры, определенные в mix.exs файле.

После того, как проект скомпилирован, можно приступить к iex сессии внутри проекта, выполнив:

```bash
$ iex -S mix
```

## Выполнение тестов

Mix также создает соответствующие, структуры для выполнения тестов нашего проекта. Mix проекты, как правило, следуют Конвенции наличия `<filename>_test.exs` файла в директории `test` для каждого файла в каталоге `lib`. По этой причине, мы можем уже найти `test/kv_test.exs` соответствующий нашему файлу `lib/kv.ex`. Пока он почти ничего не делает:

```elixir
defmodule KVTest do
  use ExUnit.Case
  doctest KV

  test "the truth" do
    assert 1 + 1 == 2
  end
end
```

Важно отметить пару вещей:

1. тестовый файл - это файл сценария ( `.exs` ) Эликсира. Это удобное соглашение, потому что нам не нужно компилировать тестовые файлы перед их запуском;

2. мы определяем тестовый модуль по имени `KVTest`, используем [`ExUnit.Case`](https://hexdocs.pm/ex_unit/ExUnit.Case.html) для введения(inject) API тестирования  и определяем простой тест с помощью макроса `test/2`;

Mix также создает файл с именем `test/test_helper.exs`, который отвечает за настройку тестовой платформы:

```elixir
ExUnit.start()
```

Этот файл будет автоматически запрашиваться Mix каждый раз перед запуском тестов. Мы можем запустить тесты с помощью команды `mix test`:

    Compiled lib/kv.ex
    Generated kv app
    [...]
    .

    Finished in 0.04 seconds (0.04s on load, 0.00s on tests)
    1 test, 0 failures

    Randomized with seed 540224

Обратите внимание, что при запуске `mix test`, Mix компилирует исходные файлы и генерирует файл приложения еще раз. Это происходит, потому что Mix поддерживает несколько окружений(environments), которые мы будем изучать в следующем разделе.

Кроме того, вы можете увидеть, что ExUnit печатает точку для каждого успешного теста и автоматически рандомизирует тесты. Давайте сделаем ошибочный тест и посмотрим, что произойдет.

Изменим утверждение `test/kv_test.exs` на следующее:

```elixir
assert 1 + 1 == 3
```

Теперь запустите `mix test` снова (заметьте, в этот раз не будет никакой компиляции):

```
  1) test the truth (KVTest)
     test/kv_test.exs:5
     Assertion with == failed
     code: 1 + 1 == 3
     lhs:  2
     rhs:  3
     stacktrace:
       test/kv_test.exs:6

Finished in 0.05 seconds (0.05s on load, 0.00s on tests)
1 test, 1 failure
```

Для каждого сбоя, ExUnit печатает подробный отчет, содержащий  имя теста, причину падения, непрошедший успешно код, и значения выражения для левой стороны (lhs) и правой стороны (rhs) для `==` оператора.

Во второй строке падения теста, сразу под названием тестового файла, есть место, где тест был определен. Если вы скопируете расположение теста на второй линии (в том числе файл и номер строки) и добавите его в `mix test` , Mix загрузит и выполнит только этот тест:

```bash
$ mix test test/kv_test.exs:5
```

Эта короткая запись будет чрезвычайно полезной, позволяет нам быстро запускать конкретный тест.

Наконец, трассировка стека во время падения(failure) дает информацию о тесте и часто о месте падения, которое было создано в исходных файлах.

## Окружения(Environments)

Mix поддерживает концепцию “Окружений”. Они позволяют разработчику настроить компиляцию и другие опции для конкретных сценариев. По умолчанию, Mix понимает три окружения:

* `:dev` - в которой Mix задания(tasks) (как `compile`) запускаются по умолчанию
* `:test` - используется `mix test`
* `:prod` - вы будете использовать это окружение, чтобы запустить свой проект в продакшн

Окружения применяется только к текущему проекту. Как мы увидим позже, любые зависимости, которые вы добавляете в проект по умолчанию будут работать в окружении `:prod`.

Настройки окружения могут быть сделаны путем доступа к [`Mix.env` функции](https://hexdocs.pm/mix/Mix.html#env/1) в файле mix.exs , которая возвращает текущее окружение как атом. Вот что мы использовали в функции `:start_permanent`:

```elixir
def project do
  [...,
   start_permanent: Mix.env == :prod,
   ...]
end
```

При компиляции исходного кода, Эликсир собирает артефакты в каталог `_build`. Однако, во многих случаях, чтобы избежать ненужного копирования, Эликсир будет создать системные ссылки filesystem links из папки `_build` к реальным исходным файлам. Если значение равно True, `:build_embedded` отключает это поведение, так как он призван обеспечить все необходимое, чтобы запустить приложение внутри каталога `_build`.

Аналогично, при установленном в True значении :start_permanent, функция запускает приложение в режиме постоянной работы, что означает, что виртуальная машина Эрланга(Erlang VM) рухнет, если ваше древо надзора(supervision tree) приложения выключается. Заметьте, мы не хотим, чтобы такое поведение было в разработке и тестировании, потому что мы хотим сохранить работающий экземпляр виртуальной машины для устранения неполадок.

Mix по умолчанию работает в `:dev` окружении, за исключением `test` задач, которые будут работать по умолчанию в среде `:test`. Окружение может быть изменено через переменную среды `MIX_ENV`:

```bash
$ MIX_ENV=prod mix compile
```

или на Windows:

```batch
> set "MIX_ENV=prod" && mix compile
```

Mix - это инструмент построения и он не всегда будет доступен в продакшн, особенно если ваша команда использует явные шаги сборки приложений, поэтому рекомендуется использовать `Mix.env` только в файлах конфигурации и внутри `mix.exs` , и никогда в коде приложения (`lib`).

## Исследование

Есть очень много всего, что хотелось бы сказать о Mix, и мы будем продолжать исследовать то, как мы строим наш проект. [Это общий обзор Mix документации](https://hexdocs.pm/mix/).

Имейте в виду, что вы всегда можете вызвать помощь по заданиям, список всех существующих задач вызовётся так:

```bash
$ mix help
```

Вы можете получить дополнительную информацию о конкретной задаче, вызывая `mix help TASK`.

Давайте напишем немного кода!
