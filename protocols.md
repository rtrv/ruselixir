---
title: Протоколы
next_page: comprehensions
prev_page: structs
---

# {{ page.title }}

Протоколы - это механизм для реализации полиморфизма в Эликсире. Обращение к протоколу доступно для любого типа данных, если этот тип реализует протокол. давайте взглянем на пример.

В Эликсире есть два способа проверить, сколько экземпляров находится в структуре данных: `length` и `size`. `length` значит, что информацию нужно вычислить. Например, `length(list)` должен пройтись по всему списку, чтобы вычислить его длину. С другой стороны, `tuple_size(tuple)` и `byte_size(binary)` просто берёт уже известный размер информации в кортеже или бинарных данных.

Даже если у нас есть встроенные в Эликсир функции для определённых типов, который получают размер (такие как `tuple_size/1`), мы могли бы реализовать общий протокол `Size`, для всех структур данных, у которых размер подсчитан заранее.

Определение протокола бы выглядело подобным образом:

```elixir
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end
```

Протокол `Size` ожидает, что есть функция `size`, которая принимает один аргумент (структуру данных, размер которой мы хотим узнать). Теперь мы можем реализовать этот протокол для структур данных:

```elixir
defimpl Size, for: BitString do
  def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

Мы не применили протокол `Size` для списков, т.к. для них нет предварительно подсчитанной информации о длине, её нужно вычислять (с помощью `length/1`).

Теперь, имея определение и реализацию протокола, мы можем начать использовать его:

```iex
iex> Size.size("foo")
3
iex> Size.size({:ok, "hello"})
2
iex> Size.size(%{label: "some label"})
1
```

Попытка узнать размер типа данных, которые не принимают этот протокол, вызовет ошибку:

```iex
iex> Size.size([1, 2, 3])
** (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3]
```

Протоколы можно применять для всех типов данных Эликсира:

* `Atom`
* `BitString`
* `Float`
* `Function`
* `Integer`
* `List`
* `Map`
* `PID`
* `Port`
* `Reference`
* `Tuple`


## Протоколы и структуры

The power of Elixir's extensibility comes when protocols and structs are used together.

Мощность расширямости Эликсира особенно хорошо проявляет себя при использовании протоколов и структур вместе.

В [предыдущей главе](/getting-started/structs.html), мы узнали, что хотя структуры являются словарями, они не разделяют реализацию протоколов словарей. Например, [`MapSet`](https://hexdocs.pm/elixir/MapSet.html) (наборы на основе словарей) реализованы как структуры. Давайте попробуем использовать протокол `Size` для `MapSet`:

```iex
iex> Size.size(%{})
0
iex> set = %MapSet{} = MapSet.new
#MapSet<[]>
iex> Size.size(set)
** (Protocol.UndefinedError) protocol Size not implemented for #MapSet<[]>
```

Вместо разделения реализации протокола со словарями, для структур необходима их собственная реализация протоколов. Т.к. размер `MapSet` подсчитан заранее и доступен через `MapSet.size/1`, мы можем добавить его в `Size`:

```elixir
defimpl Size, for: MapSet do
  def size(set), do: MapSet.size(set)
end
```

Если хотите, вы можете добавить свою семантику для размера своих собственных структур. Кроме того, вы можете использовать структуры для создания более сложных типов данных, например, очередей, и реализовать для них все подходящие протоколы, такие как `Enumerable` и, возможно, `Size`.

```elixir
defmodule User do
  defstruct [:name, :age]
end

defimpl Size, for: User do
  def size(_user), do: 2
end
```

## Реализация `Any`

Ручная реализация протоколов для всех типов может быстро стать повторяющейся и утомительной. В таких случаях в Эликсире есть два варианта: избыточно получить реализацию протокола для все типов или автоматически применить протокол для всех типов. В обоих случаях нам нужно реализовать протокол через `Any`.

### Получение протокола

Эликсир позволяет нам получить реализацию протокола, основанного на `Any`. давайте сначала реализуем `Any` как показано ниже:

```elixir
defimpl Size, for: Any do
  def size(_), do: 0
end
```

Вариант выше не самый лучший. Например, нет никакого смысла возвращать `0` как размер `PID` или `Integer`.

Однако, она имеет право на жизнь, т.к. при такой реализации `Any` нам нужно избыточно указывать в структурах применение протокола `Size`:

```elixir
defmodule OtherUser do
  @derive [Size]
  defstruct [:name, :age]
end
```

При таком подходе, Эликсир будет реализовывать протокол `Size` для `OtherUser`, основываясь на реализации для `Any`.

### Откат к `Any`

Другая альтернатива `@derive` - избыточно объявление использования `Any`, когда не найдена другая реализация. Это можно сделать, установив значение `@fallback_to_any` в `true` в определении протокола:

```elixir
defprotocol Size do
  @fallback_to_any true
  def size(data)
end
```

As we said in the previous section, the implementation of `Size` for `Any` is not one that can apply to any data type. That's one of the reasons why `@fallback_to_any` is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour. That said, assuming we have implemented `Any` as in the previous section:

Как мы сказали в предыдущей секции, реализация `Size` для `Any` не может быть применена ко всем типам данных. Это причина, по которой `@fallback_to-any` - опциональное поведение. Для большинства протоколов возникновение ошибки когда протокол не реализован - наиболее подходящее.

```elixir
defimpl Size, for: Any do
  def size(_), do: 0
end
```

Теперь все типы данных (включая структуры), которые не реализуют протокол `Size`, будут возвращать `0` при запросе размера.

Какой из подходов лучше, получение протокола через `@derive` или откат к `Any`, зависит от вашей задачи, но учитывая, что в разработке на Эликсире избыточное считается лучше, чем недостаточное, во многих библиотеках вы можете увидеть выбор в пользу использования подхода с `@derive`

## Встроенные протоколы

В Эликсир изначально встроены некотороые протоколы. В предыдущих главах мы обсуждали модуль `Enum`, который предоставляет многие функции, которые работают в любой структуре данных, которая реализует протокол `Enumerable`:

```iex
iex> Enum.map [1, 2, 3], fn(x) -> x * 2 end
[2, 4, 6]
iex> Enum.reduce 1..3, 0, fn(x, acc) -> x + acc end
6
```

Другой полезные пример - протокол `String.Chars`, который определяет, как конвертировать структуры с символами в строки. Это осуществляется функцией `to_string`:

```iex
iex> to_string :hello
"hello"
```

 Обратите внимание, что интерполяция строк в Эликсире вызывает функцию `to_string`:

```iex
iex> "age: #{25}"
"age: 25"
```

Пример выше работает только потому, что числа реализуют протокол `String.Chars`. Передача кортежа, например, приведёт к ошибке:

```iex
iex> tuple = {1, 2, 3}
{1, 2, 3}
iex> "tuple: #{tuple}"
** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, 3}
```

Когда есть необходимость "напечатать" более сложную структуру данных, можно использовать функцию `inspect`, основанную на протоколе `Inspect`:

```iex
iex> "tuple: #{inspect tuple}"
"tuple: {1, 2, 3}"
```

Протокол `Inspect` - это протокол для трансформации любой структуры данных в читабельное текстовое предствление. Именно его инструменты вроде IEx используют для вывода результатов:

```iex
iex> {1, 2, 3}
{1, 2, 3}
iex> %User{}
%User{name: "john", age: 27}
```

Помните, что есть договорённость о выводе значений, начиная с `#`, если текстовое представление не соответствует синтаксису Эликсира. Это значит, что выведенная информация не обратима в часть кода и может быть потеряна:

```iex
iex> inspect &(&1+2)
"#Function<6.71889879/1 in :erl_eval.expr/5>"
```

В Эликсире есть и другие протоколы, но мы рассмотрели самые частоиспользуемые.

## Консолидация протоколов

При работе с проектами на Эликсире, использующими средство сборки Mix, вы можете увидеть подобный вывод:

```
Consolidated String.Chars
Consolidated Collectable
Consolidated List.Chars
Consolidated IEx.Info
Consolidated Enumerable
Consolidated Inspect
```

Это протоколы, которые входят в состав Эликсира и консолидируются в данном проекте. Т.к. протокол может быть применён к любому типу данных, он должен делать проверки при каждом вызове, существует ли реализация для нужного типа. Это может быть дорого.

Однако, после компиляции нашего проекта с использованием инструмента вроде Mix, мы знаем все модули, которые определены, включая протоколы и их реализации. Это значит, что протокол может быть консолидирован в очень простой и быстрый модуль исполнения.

Начиная с Эликсира версии 1.2, консолидация протоколов происходит автоматически для всех проектов. Мы будем осуществлять сбору нашего проекта в ***Руководстве по Mix и OTP***.
